# 싱글톤 패턴(Singleton Pattern)

Created: April 1, 2022 12:14 AM
Keyword: GoF(Gang Of Four), 디자인 패턴, 싱글톤 패턴
Last Edited Time: April 1, 2022 3:43 AM
Status: IN PROGRESS

## 싱글톤 (Singleton) 패턴

---

싱글톤 패턴이란 **인스턴스를 오직 한 개만 제공하는 클래스**이다. 시스템 런타임, 환경 세팅에 대한 정보 등 인스턴스가 여러개 일 때 문제가 생길 수 있는 경우가 존재한다. 인스턴스를 **오직 한 개**만 만들어 제공하는 클래스가 필요하다.



어떻게 하면 만들 수 있을까?

- new 생성자를 통해 만들 수 없어야 한다 → private 생성자를 만들어서 클래스 안에서만 만들게 한다.
- Global하게 접근하도록 해야한다 → static 키워드를 사용한다.

```java
public class BasicSingleton {
    private static BasicSingleton instance;

    private BasicSingleton() {}
    
    public static BasicSingleton getInstance() {
        if (instance == null) {
            instance = new BasicSingleton();
        }
        
        return instance;
    }
}
```

위 코드의 문제점은 무엇일까?

- 멀티쓰레드 환경에서 인스턴스가 두 개 생성 될 수 있다.
    - Thread1, Thread2가 getInstance()메소드를 동시에 진입하게 된다면?
    - Thread1, Thread2가 Instance 생성 전에 진입하게 된다면?

Thread Safe한 방법 4가지

- getInstance 메소드에 synchronized 키워드 사용

  → Thread Safe하지만 getInstance()를 호출시에 동기화 처리로 인한 성능 저하


```java
public class ThreadSafeSingleton1 {
    private static ThreadSafeSingleton1 instance;

    private ThreadSafeSingleton1() {}

    public static synchronized ThreadSafeSingleton1 getInstance() {
        if (instance == null) {
            instance = new ThreadSafeSingleton1();
        }

        return instance;
    }
}
```

- Eager initialization(이른 초기화) 사용

  → 인스턴스가 메모리도 많이 사용하면서 사용 빈도가 낮으면 효율성 저하


```java
public class ThreadSafeSingleton2 {
    private static final ThreadSafeSingleton2 INSTANCE = new ThreadSafeSingleton2();

    private ThreadSafeSingleton2() {}

    public static ThreadSafeSingleton2 getInstance() {
        return INSTANCE;
    }
}
```

- Double checked Locking 사용 (자바 1.5버전 이상)

  : volatile 키워드는 무엇인가?

  → getInstance() 메소드를 호출 할 때마다 synchronized 메커니즘 활용하는게 아니라 인스턴스가 없을 때만 사용

  →


```java
public class ThreadSafeSingleton3 {
    private static volatile ThreadSafeSingleton3 instance;

    private ThreadSafeSingleton3() {}

    public static ThreadSafeSingleton3 getInstance() {
        if (instance == null) {
            synchronized (ThreadSafeSingleton3.class) {
                if (instance == null) {
                    instance = new ThreadSafeSingleton3();
                }
            }
        }
        return instance;
    }
}
```

- volatile 키워드를 사용하지 않고 static class로 해결

  : 멀티쓰레드 환경에서도 안전

  : getInstance() 호출이 될 때 Holder 클래스가 로딩이 이루어짐(Lazy loading)

  →


```java
public class ThreadSafeSingleton4 {
    
    private ThreadSafeSingleton4() {}

    private static class ThreadSafeSingleton4Holder {
        private static final ThreadSafeSingleton4 INSTANCE = new ThreadSafeSingleton4();
    }

    public static ThreadSafeSingleton4 getInstance() {
        return ThreadSafeSingleton4Holder.INSTANCE;
    }
}
```

=== 위 방법들을 깨트릴 수 있는 다양한 코딩 방법 ===

위 방법대로 만들었더라도 깨트릴 수 있음

1) 리플렉션을 통해 새로운 인스턴스를 만들어 깨트릴 수 있음

   ⇒ class로는 대응할 수 있는 방법이 없음..

   ⇒ enum으로 대응이 가능함 (단순하게 호출이 되면 reflection에 안전해짐) ⇒ 단점은 클래스가 로딩하는 순간 이미 만들어짐, 상속을 쓰지 못함

        ⇒ enum은 역직렬화에도 안전하게 되어 있음

2) 직렬화 & 역직렬화 사용 ⇒ 역직렬화를 하면 인스턴스를 만들어줘서 false가 됨

⇒ 역직렬화시 readResolve() 메소드를 가지고 있고 이 안에서 getInstance()를 리턴해 호출되어서 방어가 가능

⇒ 권장하는 방법 Enum을 사용하거나, static class holder를 만들어서 사용

---

싱글톤 패턴이 사용중인 곳이 어디에 있을까?

- 실행하는 환경에 대한 정보 Runtime ⇒ getRuntime()
- 다른 디자인 패턴(빌더, 퍼사드, 추상 팩토리 등) 구현체의 일부
-